# -*- coding: utf-8 -*-
#
# cfs3 documentation build configuration file, created by
# sphinx-quickstart on Tue Jun  2 11:34:13 2015.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
from datetime import datetime
from pathlib import Path

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
root = Path(__file__).absolute().parent.parent
sys.path.insert(0, str(root))

import cfs3

__version__ = cfs3.__version__

# -- RTD configuration ------------------------------------------------

# on_rtd is whether we are on readthedocs.org, this line of code grabbed from
# docs.readthedocs.org
on_rtd = os.environ.get("READTHEDOCS", None) == "True"

# This is used for linking and such so we link to the thing we're building
rtd_version = os.environ.get("READTHEDOCS_VERSION", "latest")
if rtd_version not in ["latest", "doc"]:  # TODO: add "stable" once we have it
    rtd_version = "latest"

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.napoleon',
    'autodocsumm',
]

autodoc_default_options = {
    'members': True,
    'undoc-members': True,
    'inherited-members': True,
    'show-inheritance': True,
    'autosummary': True,
}

autodoc_mock_imports = [
    'cartopy',
    'cf_units',
    'ESMF',
    'geopy',
    'iris',
    'nested_lookup',
    'psutil',
    'stratify',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'cfs3'
copyright = u'{0}, cfs3 Development Team'.format(datetime.now().year)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '.'.join(__version__.split('.')[0:1])
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns: list = []

# The reST default role (used for this markup: `text`) to use for all
# documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False

# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
html_short_title = "cfs3 {0}".format(release)

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# FIXME add a logo
html_logo = "figures/cfs3-logo.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path: list = []

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
# html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'cfs3doc'

# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    'preamble':
    r'''
   \makeatletter
   \renewcommand{\maketitle}{
     \newcommand{\MONTH}{%
       \ifcase\the\month
       \or January% 1
       \or February% 2
       \or March% 3
       \or April% 4
       \or May% 5
       \or June% 6
       \or July% 7
       \or August% 8
       \or September% 9
       \or October% 10
       \or November% 11
       \or December% 12
     \fi}
     \begin{titlepage}
     \begin{center}
     \includegraphics[width=\textwidth]{figures/logo.pdf}\par
     \vspace{2cm}
     {\Huge \bf \sffamily User's and Developer's Guide \par}
     \vspace{1cm}
     {\Large \sffamily \MONTH ~ \the\year \par}
     \vspace{0.5cm}
     http://www.cfs3isawesome.co.uk/ \par
     \end{center}
     \end{titlepage}
     \clearpage
   }
   \makeatother'''
}

# latex_additional_files = []

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    ('index', 'cfs3_Users_Guide.tex',
     u'cfs3 User\'s and Developer\'s Guide',
     u'cfs3 Development Team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = True
latex_toplevel_sectioning = "part"

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True


# If true, show URL addresses after external links.
# man_show_urls = False

# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
# texinfo_documents = [
#  ('index', 'cfs3', u'cfs3 Documentation',
#   u'Bryan Lawrence, David Hassell et al.',
#   'cfs3',
#   'One line #description of project.',
#   'Miscellaneous'),
# ]

# Documents to append as an appendix to all manuals.
# texinfo_appendices = []

# If false, no module index is generated.
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
# texinfo_no_detailmenu = False

# -- Options for Epub output ----------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'cfs3'
epub_author = u'cfs3 Development Team'
epub_publisher = u'cfs3 Development Team'
epub_copyright = u'cfs3 Development Team'

# The basename for the epub file. It defaults to the project name.
# epub_basename = u'cfs3'

# The HTML theme for the epub output. Since the default themes are not
# optimized for small screen space, using the same theme for HTML and epub
# output is usually not wise. This defaults to 'epub', a theme designed to
# save visual space.
# epub_theme = 'epub'

# The language of the text. It defaults to the language option
# or en if the language is not set.
# epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
# epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
# epub_identifier = ''

# A unique identification for the text.
# epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
# epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
# epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_post_files = []

# A list of files that should not be packed into the epub file.
epub_exclude_files = ['search.html']

# The depth of the table of contents in toc.ncx.
# epub_tocdepth = 3

# Allow duplicate toc entries.
# epub_tocdup = True

# Choose between 'default' and 'includehidden'.
# epub_tocscope = 'default'

# Fix unsupported image types using the PIL.
# epub_fix_images = False

# Scale large images.
# epub_max_image_width = 0

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# epub_show_urls = 'inline'

# If false, no index is generated.
# epub_use_index = True

numfig = True

# Configuration for intersphinx
intersphinx_mapping = {
    'matplotlib': ('https://matplotlib.org/', None),
    'numpy': ('https://numpy.org/doc/stable/', None),
    'python': ('https://docs.python.org/3/', None),
    'scipy': ('https://docs.scipy.org/doc/scipy/', None),
}

# -- Custom Document processing ----------------------------------------------

sys.path.append(os.path.dirname(__file__))
from gensidebar import generate_sidebar

generate_sidebar(globals(), "cfs3")

import inspect
import textwrap
import cmd2
from sphinx.ext.autodoc import FunctionDocumenter
from sphinx.ext.autosummary import Autosummary
from docutils import nodes
from docutils.statemachine import ViewList
import sphinx.ext.autodoc.directive as autodocdir
from sphinx import addnodes

# ---------------------------------------------------------------------
# Helper functions for argparse formatting
# ---------------------------------------------------------------------
def format_argparser_summary(parser):
    """Return short one-line summary of parser arguments for table display."""
    parts = []
    for a in parser._actions:
        if getattr(a, "help", None) == "==SUPPRESS==":
            continue
        if not getattr(a, "option_strings", None):
            parts.append(a.dest)
        else:
            parts.append("/".join(a.option_strings))
    return ", ".join(parts) if parts else ""


def format_argparser_rst(parser):
    """Return full RST-formatted argument list for docstrings."""
    lines = []
    positionals = [a for a in parser._actions if not a.option_strings and a.help != "==SUPPRESS=="]
    if positionals:
        lines.append("**Positional Arguments:**")
        for a in positionals:
            lines.append(f"- ``{a.dest}``: {a.help or ''}")

    optionals = [a for a in parser._actions if a.option_strings and a.help != "==SUPPRESS=="]
    if optionals:
        lines.append("")
        lines.append("**Optional Arguments:**")
        for a in optionals:
            opts = ", ".join(a.option_strings)
            lines.append(f"- ``{opts}``: {a.help or ''}")

    return [textwrap.fill(line, width=90) if not line.startswith("**") else line for line in lines]


# ---------------------------------------------------------------------
# autodoc: skip members except do_* commands
# ---------------------------------------------------------------------
def autodoc_skip_member(app, what, name, obj, skip, options):
    """Keep only do_* methods defined on subclasses of cmd2.Cmd."""
    if inspect.isclass(obj) and issubclass(obj, cmd2.Cmd):
        return False

    if inspect.isfunction(obj) and name.startswith("do_"):
        defining_class = getattr(obj, "__qualname__", "").split(".")[0]
        if defining_class == "Cmd":  # inherited from base cmd2.Cmd
            return True
        return False

    return True


# ---------------------------------------------------------------------
# Custom documenter for cmd2 commands
# ---------------------------------------------------------------------
class Cmd2CommandDocumenter(FunctionDocumenter):
    """Documenter for cmd2 do_* methods."""

    objtype = "cmd2command"
    directivetype = "function"
    priority = FunctionDocumenter.priority + 10

    @classmethod
    def can_document_member(cls, member, membername, isattr, parent):
        return inspect.isfunction(member) and membername.startswith("do_")

    def format_name(self):
        name = getattr(self.object, "__name__", "")
        return name[3:] if name.startswith("do_") else name

    def get_signature(self, *args, **kwargs):
        sig = super().get_signature(*args, **kwargs) or ""
        sig = sig.strip()
        if sig.startswith("(") and sig.endswith(")"):
            inner = sig[1:-1].strip()
            parts = [p.strip() for p in inner.split(",") if p.strip()]
            if parts and parts[0] == "self":
                parts = parts[1:]
            sig = "(" + ", ".join(parts) + ")"
        return sig

    def add_content(self, more_content=None):
        """Append argparse information if available."""
        parser = getattr(self.object, "argparser", None)
        if not parser:
            return

        lines = [""]
        lines.append("**Command Arguments:**")
        lines.extend(["    " + l for l in format_argparser_rst(parser)])

        viewlist = ViewList()
        srcname = f"{self.object.__module__}.{self.object.__name__} (autodoc)"
        for line in lines:
            viewlist.append(line, srcname)

        super().add_content(viewlist)


# ---------------------------------------------------------------------
# Autosummary patch to rename do_* and add summaries
# ---------------------------------------------------------------------
_original_get_items = Autosummary.get_items


def autosummary_get_items(self, *args, **kwargs):
    """Patch Autosummary.get_items to handle cmd2 commands."""
    if len(args) == 1:
        return _original_get_items(self, *args, **kwargs)

    items = _original_get_items(self, *args, **kwargs)
    new_items = []
    for name, sig_text, summary, real_name in items:
        if name.startswith("do_"):
            cmd_name = name[3:]
            try:
                module_name, func_name = real_name.rsplit(".", 1)
                mod = __import__(module_name, fromlist=[func_name])
                func = getattr(mod, func_name)
                doc = inspect.getdoc(func)
                if doc:
                    summary = doc.strip().splitlines()[0]
                parser = getattr(func, "argparser", None)
                if parser:
                    arg_summary = format_argparser_summary(parser)
                    if arg_summary:
                        summary = f"{summary} ({arg_summary})" if summary else arg_summary
            except Exception:
                pass
            new_items.append((cmd_name, sig_text, summary, real_name))
        else:
            new_items.append((name, sig_text, summary, real_name))
    return new_items


Autosummary.get_items = autosummary_get_items


# ---------------------------------------------------------------------
# doctree post-processor to remove stray "Miscellaneous"/empty "Commands"
# ---------------------------------------------------------------------
def _is_bold_commands_paragraph(node):
    if isinstance(node, nodes.paragraph):
        t = node.astext().strip()
        return t in ("Commands:", "**Commands:**")
    return False

def fix_miscellaneous_sections(app, doctree, fromdocname):
    for section in list(doctree.traverse(nodes.section)):
        titles = section.traverse(nodes.title)
        if not titles:
            continue
        title_text = titles[0].astext().strip()

        contains_cmd2 = any(
            isinstance(n, addnodes.desc) and any(
                isinstance(child, addnodes.desc_name)
                and child.astext().strip()
                and not child.astext().startswith("do_")
                for child in n.children
            )
            for n in section.traverse(addnodes.desc)
        )

        if not contains_cmd2:
            contains_cmd2 = any(
                "Command Arguments:" in n.astext()
                for n in section.traverse(nodes.paragraph)
            )

        if contains_cmd2 and title_text == "Miscellaneous":
            titles[0].children[:] = [nodes.Text("Commands")]

    # create a Commands section if none exists
    top_sections = [n for n in doctree.children if isinstance(n, nodes.section)]
    if not top_sections:
        cmd_nodes = [n for n in doctree.traverse(addnodes.desc)
                     if any(isinstance(child, addnodes.desc_name) for child in n.children)]
        if cmd_nodes:
            new_section = nodes.section(ids=["commands"])
            new_section += nodes.title(text="Commands")
            for n in cmd_nodes:
                n.parent.remove(n)
                new_section += n
            doctree += new_section


def rename_miscellaneous_to_commands(app, doctree, fromdocname):
    """
    Final safety net:
    Rename any visible section or rubric titled 'Miscellaneous' to 'Commands'.
    Works regardless of Sphinx internal node hierarchy.
    """
    for title in doctree.traverse(nodes.title):
        if title.astext().strip() == "Miscellaneous":
            title.children[:] = [nodes.Text("Commands")]

    for rubric in doctree.traverse(nodes.rubric):
        if rubric.astext().strip() == "Miscellaneous":
            rubric.children[:] = [nodes.Text("Commands")]

# ---------------------------------------------------------------------
# Sphinx setup
# ---------------------------------------------------------------------
def setup(app):
    app.add_autodocumenter(Cmd2CommandDocumenter)
    app.connect("autodoc-skip-member", autodoc_skip_member)
    app.connect("doctree-resolved", fix_miscellaneous_sections)
    app.connect("doctree-resolved", rename_miscellaneous_to_commands)
